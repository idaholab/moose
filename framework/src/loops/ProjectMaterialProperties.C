//* This file is part of the MOOSE framework
//* https://mooseframework.inl.gov
//*
//* All rights reserved, see COPYRIGHT for full restrictions
//* https://github.com/idaholab/moose/blob/master/COPYRIGHT
//*
//* Licensed under LGPL 2.1, please see LICENSE for details
//* https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include "ProjectMaterialProperties.h"
#include "Problem.h"
#include "FEProblem.h"
#include "MaterialPropertyStorage.h"
#include "MaterialData.h"
#include "Assembly.h"
#include "AuxKernel.h"

#include "libmesh/threads.h"
#include "libmesh/elem.h"

ProjectMaterialProperties::ProjectMaterialProperties(
    bool refine,
    FEProblemBase & fe_problem,
    MaterialPropertyStorage & material_props,
    MaterialPropertyStorage & bnd_material_props,
    std::vector<std::vector<std::unique_ptr<Assembly>>> & assembly)
  : ThreadedElementLoop<ConstElemPointerRange>(fe_problem),
    _refine(refine),
    _fe_problem(fe_problem),
    _material_props(material_props),
    _bnd_material_props(bnd_material_props),
    _assembly(assembly),
    _need_internal_side_material(false),
    _materials(_fe_problem.getRegularMaterialsWarehouse()),
    _discrete_materials(_fe_problem.getDiscreteMaterialWarehouse())
{
}

// Splitting Constructor
ProjectMaterialProperties::ProjectMaterialProperties(ProjectMaterialProperties & x,
                                                     Threads::split split)
  : ThreadedElementLoop<ConstElemPointerRange>(x, split),
    _refine(x._refine),
    _fe_problem(x._fe_problem),
    _material_props(x._material_props),
    _bnd_material_props(x._bnd_material_props),
    _assembly(x._assembly),
    _need_internal_side_material(x._need_internal_side_material),
    _materials(x._materials),
    _discrete_materials(x._discrete_materials)
{
}

ProjectMaterialProperties::~ProjectMaterialProperties() {}

void
ProjectMaterialProperties::subdomainChanged()
{
  _need_internal_side_material = _fe_problem.needInternalNeighborSideMaterial(_subdomain, _tid);
}

void
ProjectMaterialProperties::onElement(const Elem * elem)
{
  // This check mirrors the check in ComputeMaterialsObjectThread::onElement as it must because it
  // is possible that there are no materials on this element's subdomain, e.g. if we are doing
  // mortar, in which case the properties will not have been resized in
  // ComputeMaterialsObjectThread::onElement, and consequently if we were to proceed we would get
  // bad access errors
  if (!_materials.hasActiveBlockObjects(elem->subdomain_id(), _tid) &&
      !_discrete_materials.hasActiveBlockObjects(elem->subdomain_id(), _tid))
    return;

  _assembly[_tid][0]->reinit(elem);

  if (_refine)
  {
    if (_mesh.doingPRefinement())
    {
      const auto & p_refinement_map = _mesh.getPRefinementMap(*elem);
      _material_props.updateStatefulPropsForPRefinement(_mesh.processor_id(),
                                                        p_refinement_map,
                                                        *_assembly[_tid][0]->qRule(),
                                                        *_assembly[_tid][0]->qRuleFace(),
                                                        _tid,
                                                        *elem,
                                                        -1);
    }
    else
    {
      const std::vector<std::vector<QpMap>> & refinement_map =
          _mesh.getRefinementMap(*elem, -1, -1, -1);

      _material_props.prolongStatefulProps(
          _mesh.processor_id(),
          refinement_map,
          *_assembly[_tid][0]->qRule(),
          *_assembly[_tid][0]->qRuleFace(),
          _material_props, // Passing in the same properties to do volume to volume projection
          _tid,
          *elem,
          -1,
          -1,
          -1); // Gets us volume projection
    }
  }
  else
  {
    if (_mesh.doingPRefinement())
    {
      const auto & p_coarsening_map = _mesh.getPCoarseningMap(*elem);
      _material_props.updateStatefulPropsForPRefinement(_mesh.processor_id(),
                                                        p_coarsening_map,
                                                        *_assembly[_tid][0]->qRule(),
                                                        *_assembly[_tid][0]->qRuleFace(),
                                                        _tid,
                                                        *elem,
                                                        -1);
    }
    else
    {
      const std::vector<std::pair<unsigned int, QpMap>> & coarsening_map =
          _mesh.getCoarseningMap(*elem, -1);

      _material_props.restrictStatefulProps(coarsening_map,
                                            _mesh.coarsenedElementChildren(elem),
                                            *_assembly[_tid][0]->qRule(),
                                            *_assembly[_tid][0]->qRuleFace(),
                                            _tid,
                                            *elem,
                                            -1);
    }
  }
}

void
ProjectMaterialProperties::onBoundary(const Elem * elem,
                                      unsigned int side,
                                      BoundaryID bnd_id,
                                      const Elem * /*lower_d_elem = nullptr*/)
{
  if (_fe_problem.needBoundaryMaterialOnSide(bnd_id, _tid) &&
      _bnd_material_props.hasStatefulProperties())
  {
    _assembly[_tid][0]->reinit(elem, side);

    if (_refine)
    {
      if (_mesh.doingPRefinement())
      {
        const auto & p_refinement_map = _mesh.getPRefinementSideMap(*elem);
        _bnd_material_props.updateStatefulPropsForPRefinement(_mesh.processor_id(),
                                                              p_refinement_map,
                                                              *_assembly[_tid][0]->qRule(),
                                                              *_assembly[_tid][0]->qRuleFace(),
                                                              _tid,
                                                              *elem,
                                                              side);
      }
      else
      {
        const std::vector<std::vector<QpMap>> & refinement_map =
            _mesh.getRefinementMap(*elem, side, -1, side);

        _bnd_material_props.prolongStatefulProps(
            _mesh.processor_id(),
            refinement_map,
            *_assembly[_tid][0]->qRule(),
            *_assembly[_tid][0]->qRuleFace(),
            _bnd_material_props, // Passing in the same properties to do side_to_side projection
            _tid,
            *elem,
            side,
            -1,
            side); // Gets us side to side projection
      }
    }
    else
    {
      if (_mesh.doingPRefinement())
      {
        const auto & p_coarsening_map = _mesh.getPCoarseningSideMap(*elem);
        _bnd_material_props.updateStatefulPropsForPRefinement(_mesh.processor_id(),
                                                              p_coarsening_map,
                                                              *_assembly[_tid][0]->qRule(),
                                                              *_assembly[_tid][0]->qRuleFace(),
                                                              _tid,
                                                              *elem,
                                                              side);
      }
      else
      {
        const std::vector<std::pair<unsigned int, QpMap>> & coarsening_map =
            _mesh.getCoarseningMap(*elem, side);

        _bnd_material_props.restrictStatefulProps(coarsening_map,
                                                  _mesh.coarsenedElementChildren(elem),
                                                  *_assembly[_tid][0]->qRule(),
                                                  *_assembly[_tid][0]->qRuleFace(),
                                                  _tid,
                                                  *elem,
                                                  side);
      }
    }
  }
}

void
ProjectMaterialProperties::onInternalSide(const Elem * elem, unsigned int /*side*/)
{
  if (_need_internal_side_material &&
      _refine) // If we're refining then we need to also project "internal" child sides.
  {
    mooseError("I'm pretty sure we're not handling stateful material property prolongation or "
               "restriction correctly on internal sides");
    for (unsigned int child = 0; child < elem->n_children(); child++)
    {
      const Elem * child_elem = elem->child_ptr(child);

      for (unsigned int side = 0; side < child_elem->n_sides(); side++)
      {
        if (!elem->is_child_on_side(child, side)) // Otherwise we already projected it
        {
          const std::vector<std::vector<QpMap>> & refinement_map =
              _mesh.getRefinementMap(*elem, -1, child, side);

          _bnd_material_props.prolongStatefulProps(
              _mesh.processor_id(),
              refinement_map,
              *_assembly[_tid][0]->qRule(),
              *_assembly[_tid][0]->qRuleFace(),
              _material_props, // Passing in the same properties to do side_to_side projection
              _tid,
              *elem,
              -1,
              child,
              side); // Gets us volume to side projection
        }
      }
    }
  }
}

void
ProjectMaterialProperties::join(const ProjectMaterialProperties & /*y*/)
{
}
