# VariationalKernelBase

!syntax description /Kernels/VariationalKernelBase

## Overview

`VariationalKernelBase` is the primary kernel class generated by the `AutomaticWeakFormAction` for implementing variational problems. It automatically computes weak form residuals and Jacobians from energy functionals using symbolic differentiation and the calculus of variations.

## Theory

### Variational Formulation

For an energy functional:

```
F[u] = ∫_Ω f(x, u, ∇u, ∇²u, ...) dx
```

The variational derivative (Euler-Lagrange equation) gives the strong form:

```
δF/δu = ∂f/∂u - ∇·(∂f/∂∇u) + ∇²:(∂f/∂∇²u) - ...
```

### Weak Form

The weak form is obtained through integration by parts:

```
R = ∫_Ω [C⁰·v - C¹·∇v + C²:∇²v - ...] dx
```

where:
- `C^k = ∂f/∂(∇^k u)` are the variational derivative coefficients
- `v` is the test function
- Integration by parts eliminates explicit divergence operators

## Features

### Energy Types

The kernel supports various predefined energy functionals:

- **DOUBLE_WELL**: Phase-field models with `f = (u²-1)²`
- **ELASTIC**: Linear elasticity with strain energy
- **NEO_HOOKEAN**: Nonlinear elasticity for finite deformations
- **SURFACE**: Interface/surface tension models
- **CAHN_HILLIARD**: Phase separation with gradient energy
- **FOURTH_ORDER**: Higher-order regularization terms
- **EXPRESSION**: Custom user-defined energy expressions

### Automatic Differentiation

The kernel computes derivatives through:
1. **Symbolic differentiation** of the energy functional (exact)
2. **Automatic differentiation** for Jacobian computation
3. **Numerical finite differences** (optional fallback)

### Coupled Variables

The kernel automatically handles coupled multi-physics problems:
- Variables are coupled based on the energy expression
- Coupling is established through the `coupled_vars` parameter
- Each variable can access values and gradients of coupled variables

## Syntax

!syntax parameters /Kernels/VariationalKernelBase

## Input Parameters

### Energy Specification

- `energy_type`: Type of energy functional (EXPRESSION, DOUBLE_WELL, etc.)
- `energy_expression`: Mathematical expression for custom energy density
- `parameters`: Named parameters as key-value pairs

### Coupling

- `coupled_vars`: Variables coupled through the energy functional (automatically set by AutomaticWeakFormAction)

### Numerical Options

- `use_automatic_differentiation`: Use AD for exact Jacobian (default: true)
- `compute_jacobian_numerically`: Use finite differences (default: false)
- `fd_eps`: Finite difference epsilon (default: 1e-8)

### Physical Parameters

- `gradient_coefficient`: Coefficient for gradient energy terms (κ)
- `fourth_order_coefficient`: Coefficient for fourth-order terms (λ)
- `elastic_lambda`: First Lamé parameter
- `elastic_mu`: Second Lamé parameter (shear modulus)
- `surface_energy_coefficient`: Surface tension coefficient (γ)

## Examples

### Example 1: Cahn-Hilliard Equation

Generated automatically by AutomaticWeakFormAction:

```
[Kernels]
  [c_variational]
    type = VariationalKernelBase
    variable = c
    energy_type = EXPRESSION
    energy_expression = 'W(c) + 0.5*kappa*dot(grad(c), grad(c))'
    parameters = 'kappa 0.01'
    use_automatic_differentiation = true
  []
[]
```

### Example 2: Coupled Phase-Field with Temperature

```
[Kernels]
  [c_variational]
    type = VariationalKernelBase
    variable = c
    energy_type = EXPRESSION
    energy_expression = 'W(c) + 0.5*kappa*dot(grad(c), grad(c)) + beta*c*T'
    parameters = 'kappa 0.01 beta 0.1'
    coupled_vars = 'T'  # Automatically coupled
    use_automatic_differentiation = true
  []

  [T_variational]
    type = VariationalKernelBase
    variable = T
    energy_type = EXPRESSION
    energy_expression = '0.5*k_th*dot(grad(T), grad(T)) + beta*c*T'
    parameters = 'k_th 1.0 beta 0.1'
    coupled_vars = 'c'  # Automatically coupled
    use_automatic_differentiation = true
  []
[]
```

### Example 3: Fourth-Order Problem with Splitting

When variable splitting is used for higher-order derivatives:

```
[Kernels]
  [c_variational]
    type = VariationalKernelBase
    variable = c
    energy_type = EXPRESSION
    # Original: grad(grad(c))
    # Transformed: c_hess (split variable)
    energy_expression = 'W(c) + 0.5*kappa*dot(grad(c), grad(c)) + 0.5*lambda*dot(c_hess, c_hess)'
    parameters = 'kappa 0.01 lambda 0.001'
    coupled_vars = 'c_hess'  # Split variable
    use_automatic_differentiation = true
  []
[]
```

## Implementation Details

### Residual Computation

The residual implements the weak form with variational coefficients:

```cpp
Real VariationalKernelBase::computeQpResidual()
{
  // Compute variational derivative coefficients
  auto diff = computeVariationalDerivative(_energy_density);

  Real residual = 0.0;

  // C⁰ term: ∂f/∂u · test
  if (diff.hasOrder(0))
    residual += evaluateC0() * _test[_i][_qp];

  // C¹ term: -∂f/∂(∇u) · ∇test
  if (diff.hasOrder(1))
    residual -= evaluateC1() * _grad_test[_i][_qp];

  // C² term: ∂f/∂(∇²u) : ∇²test (if available)
  if (diff.hasOrder(2) && _fe_order >= 2)
    residual += evaluateC2() : hessian_test[_i][_qp];

  return residual;
}
```

### Jacobian Computation

The Jacobian is computed through automatic or symbolic differentiation:

```cpp
Real VariationalKernelBase::computeQpJacobian()
{
  Real jacobian = 0.0;

  // Contribution from C⁰ term
  if (hasC0Term())
  {
    auto dc0_du = differentiateC0WithRespectToField();
    jacobian += dc0_du * _phi[_j][_qp] * _test[_i][_qp];
  }

  // Contribution from C¹ term
  if (hasC1Term())
  {
    auto dc1_du = differentiateC1WithRespectToField();
    auto dc1_dgradu = differentiateC1WithRespectToGradient();

    jacobian -= dc1_du * _phi[_j][_qp] * _grad_test[_i][_qp];
    jacobian -= dc1_dgradu * _grad_phi[_j][_qp] * _grad_test[_i][_qp];
  }

  return jacobian;
}
```

### Expression Evaluation

Custom energy expressions are parsed and evaluated symbolically:

1. **Parsing**: String expressions converted to AST
2. **Differentiation**: Symbolic derivatives computed
3. **Evaluation**: Efficient evaluation at quadrature points
4. **Caching**: Results cached to avoid recomputation

### Coupled Variable Access

Coupled variables are accessed through maps:

```cpp
// In setupCoupledVariables()
_coupled_values["T"] = &coupledValue("coupled_vars", 0);
_coupled_gradients["T"] = &coupledGradient("coupled_vars", 0);

// During evaluation
Real T_value = (*_coupled_values["T"])[_qp];
RealGradient T_grad = (*_coupled_gradients["T"])[_qp];
```

## Performance Considerations

- **Symbolic Simplification**: Expressions simplified at compile time
- **Common Subexpression Elimination**: Repeated terms computed once
- **AD Efficiency**: Automatic differentiation provides exact, efficient Jacobians
- **Vectorization**: SIMD operations where applicable

## Debugging

Enable verbose output for debugging:

```
[Kernels]
  [debug_kernel]
    type = VariationalKernelBase
    variable = u
    energy_type = EXPRESSION
    energy_expression = '...'
    verbose = true  # Shows parsed expressions and derivatives
  []
[]
```

Debug output includes:
- Parsed energy expression
- Computed variational derivative coefficients
- Transformed expressions (if splitting used)
- Residual and Jacobian contributions

## Limitations

1. **Derivative Order**: Standard FEM limited to 2nd-order derivatives without splitting
2. **Tensor Mechanics**: Full tensor mechanics requires specialized expressions
3. **Nonlocal Terms**: Integral operators not directly supported

## See Also

- [AutomaticWeakFormAction.md] - Generates these kernels automatically
- [GradientConstraintKernel.md] - Enforces constraints for split variables
- [ScalarGradientConstraint.md] - Scalar constraint for splitting
- [VectorGradientConstraint.md] - Vector constraint for splitting

!syntax children /Kernels/VariationalKernelBase