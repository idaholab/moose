# GradientConstraintKernel

!syntax description /Kernels/GradientConstraintKernel

## Overview

`GradientConstraintKernel` is a specialized kernel for enforcing gradient constraints in variable splitting schemes. It is automatically generated by the `AutomaticWeakFormAction` when higher-order PDEs are split into systems of lower-order equations.

## Purpose

When solving PDEs with derivatives of order higher than what standard finite elements support (typically > 2), the problem must be reformulated. The `GradientConstraintKernel` enforces the constraint equations that define auxiliary variables as derivatives of primary variables.

## Theory

### Variable Splitting

For a 4th-order PDE with term `∇⁴u`, the splitting introduces:

```
q = ∇²u  (auxiliary variable)
```

This transforms the 4th-order term:
```
∇⁴u → ∇²q
```

The constraint `q = ∇²u` must be enforced weakly.

### Weak Form of Constraint

The strong form constraint:
```
q - ∇²u = 0
```

Has the weak form:
```
∫_Ω (q·v + ∇u·∇v) dx = 0
```

where `v` is the test function for `q`.

## Mathematical Formulation

### General Form

For a constraint of the form:
```
auxiliary_var = ∇ⁿ(primary_var)
```

The weak form residual is:
```
R = ∫_Ω [auxiliary_var·test - (∇ⁿ⁻¹primary_var)·∇test] dx
```

### First-Order Constraint

For `q = ∇u`:
```
R = ∫_Ω [q·v + u·∇·v] dx
```

### Second-Order Constraint

For `q = ∇²u`:
```
R = ∫_Ω [q·v + ∇u·∇v] dx
```

## Implementation

The kernel implements the weak form of the gradient constraint:

```cpp
Real GradientConstraintKernel::computeQpResidual()
{
  // For constraint: aux_var = ∇ⁿ(primary_var)

  if (_constraint_order == 1)
  {
    // q = ∇u constraint
    return _u[_qp] * _test[_i][_qp]
           + _coupled_var_grad[_qp] * _grad_test[_i][_qp];
  }
  else if (_constraint_order == 2)
  {
    // q = ∇²u constraint
    return _u[_qp] * _test[_i][_qp]
           - _coupled_var_hessian[_qp] : _grad_test[_i][_qp];
  }
}
```

## Syntax

!syntax parameters /Kernels/GradientConstraintKernel

## Input Parameters

### Required Parameters

- `variable`: The auxiliary split variable
- `coupled_variable`: The primary variable being constrained
- `constraint_order`: Order of the derivative constraint (1 for gradient, 2 for Hessian)

### Optional Parameters

- `use_automatic_differentiation`: Enable AD for Jacobian computation
- `scaling_factor`: Optional scaling for the constraint equation

## Examples

### Example 1: Fourth-Order Splitting

For a 4th-order Cahn-Hilliard equation:

```
[Variables]
  [c]
    order = FIRST
    family = LAGRANGE
  []
  [c_hess]  # Auxiliary variable for ∇²c
    order = FIRST
    family = LAGRANGE
  []
[]

[Kernels]
  # Primary equation with split variable
  [c_equation]
    type = VariationalKernelBase
    variable = c
    energy_expression = 'W(c) + 0.5*lambda*dot(c_hess, c_hess)'
    # c_hess replaces grad(grad(c))
  []

  # Constraint: c_hess = ∇²c
  [hessian_constraint]
    type = GradientConstraintKernel
    variable = c_hess
    coupled_variable = c
    constraint_order = 2
  []
[]
```

### Example 2: Sixth-Order Splitting

For a 6th-order problem, multiple auxiliary variables:

```
[Variables]
  [u]
    order = FIRST
    family = LAGRANGE
  []
  [u_grad]  # ∇u
    order = FIRST
    family = LAGRANGE
  []
  [u_laplacian]  # ∇²u
    order = FIRST
    family = LAGRANGE
  []
[]

[Kernels]
  # Constraint: u_grad = ∇u
  [grad_constraint]
    type = GradientConstraintKernel
    variable = u_grad
    coupled_variable = u
    constraint_order = 1
  []

  # Constraint: u_laplacian = ∇²u
  [laplacian_constraint]
    type = GradientConstraintKernel
    variable = u_laplacian
    coupled_variable = u
    constraint_order = 2
  []
[]
```

## Automatic Generation

The `AutomaticWeakFormAction` automatically creates these kernels when:

1. Energy expression contains derivatives of order > `max_fe_order`
2. `enable_splitting = true` is set
3. Split variables are generated for high-order derivatives

The action handles:
- Creating auxiliary variables
- Transforming the energy expression
- Generating appropriate constraint kernels

## Numerical Considerations

### Stability

- The constraint is enforced weakly, allowing small violations
- Strong enforcement can lead to saddle-point problems
- Proper scaling improves condition number

### Convergence

- Constraint residuals should decrease with mesh refinement
- Monitor both primary and constraint equation residuals
- May require special preconditioners for saddle-point structure

### Conservation

- Variable splitting preserves conservation properties
- Energy dissipation maintained if original PDE is gradient flow

## Debugging

Monitor constraint satisfaction:

```
[Postprocessors]
  [constraint_error]
    type = L2Norm
    variable = c_hess
    execute_on = 'timestep_end'
  []
[]
```

## See Also

- [AutomaticWeakFormAction.md] - Automatically generates these constraints
- [ScalarGradientConstraint.md] - Scalar version for 1D problems
- [VectorGradientConstraint.md] - Vector version for vector fields
- [VariationalKernelBase.md] - Primary equation kernels

!syntax children /Kernels/GradientConstraintKernel