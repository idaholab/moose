# Kernels System

A "Kernel" is a piece of physics. It can represent one or more operators or terms in the weak form of
a partial differential equation.  With all terms on the left-hand-side, their sum is referred to as
the "residual". The residual is evaluated at several integration quadrature points over the problem
domain. To implement your own physics in MOOSE, you create your own kernel by subclassing the MOOSE
`Kernel` class.

The Kernel system supports the use of [!ac](AD) for residual calculations, as such
there are two options for creating Kernel objects: `Kernel` and `ADKernel`. To further understand
automatic differentiation, please refer to the [automatic_differentiation/index.md] page for more
information.

In a `Kernel` subclass the `computeQpResidual()` function +must+ be overridden.  This is where you
implement your PDE weak form terms.  For non-AD objects the following member functions can
optionally be overridden:

- `computeQpJacobian()`
- `computeQpOffDiagJacobian()`

These two functions provide extra information that can help the numerical solver(s) converge faster
and better.

Inside your Kernel class, you have access to several member variables for computing the
residual and Jacobian values in the above mentioned functions:

- `_i`, `_j`: indices for the current test and trial shape functions respectively.
- `_qp`: current quadrature point index.
- `_u`, `_grad_u`: value and gradient of the variable this Kernel operates on;
  indexed by `_qp` (i.e. `_u[_qp]`).
- `_test`, `_grad_test`: value ($\psi$) and gradient ($\nabla \psi$) of the
  test functions at the q-points; indexed by `_i` and then `_qp` (i.e., `_test[_i][_qp]`).
- `_phi`, `_grad_phi`: value ($\phi$) and gradient ($\nabla \phi$) of the
    trial functions at the q-points; indexed by `_j` and then `_qp` (i.e., `_phi[_j][_qp]`).
- `_q_point`: XYZ coordinates of the current quadrature point.
- `_current_elem`: pointer to the current element being operated on.

## Optimized Kernel Objects id=optimized

Depending on the residual calculation being performed it is sometimes possible to optimize the
calculation of the residual by precomputing values during the finite element assembly of
the residual vector. The following table details the various Kernel base classes that can be used
for as base classes to improve performance.

| Base | Override | Use |
| :- | :- | :- |
| Kernel\\ +ADKernel+ | computeQpResidual | Use when the term in the [!ac](PDE) is multiplied by both the test function and the gradient of the test function (`_test` and `_grad_test` must be applied) |
| KernelValue\\ +ADKernelValue+ | precomputeQpResidual | Use when the term computed in the [!ac](PDE) is only multiplied by the test function (do not use `_test` in the override, it is applied automatically) |
| KernelGrad\\ +ADKernelGrad+ | precomputeQpResidual | Use when the term computed in the [!ac](PDE) is only multiplied by the gradient of the test function (do not use `_grad_test` in the override, it is applied automatically) |

## Custom Kernel Creation

To create a custom kernel, you can follow the pattern of the [`Diffusion`](/Diffusion.md) or
[`ADDiffusion`](/ADDiffusion.md) objects implemented and included in the MOOSE framework.
Additionally, [Example 2](examples/custom_kernel.md optional=True) in MOOSE provides a step-by-step
overview of creating your own custom kernel. The following describes that calculation of the
diffusion term of a PDE.

The strong-form of the diffusion equation is defined on a 3-D domain $\Omega$ as: find $u$ such
that

!equation id=strong-form
\begin{aligned}
-\nabla\cdot\nabla u &= 0 \in \Omega\\
u|_{\partial\Omega_1} &= g_1\\
\nabla u\cdot \hat{n} |_{\partial\Omega_2} &= g_2,
\end{aligned}

where $\partial\Omega_1$ is defined as the boundary on which the value of $u$ is fixed to a known
constant $g_1$, $\partial\Omega_2$ is defined as the boundary on which the flux across the boundary
is fixed to a known constant $g_2$, and $\hat{n}$ is the boundary outward normal.

The weak form is generated by multiplying by a test function ($\psi_i$) and integrating over the
domain (using inner-product notation):

!equation
(-\nabla\cdot\nabla u_h, \psi_i) = 0\quad \forall\,\psi_i

and then integrating by parts which gives the weak form:

!equation id=weak-form
(\nabla u_h, \nabla \psi_i) - \langle g_2, \psi_i\rangle = 0\quad \forall\,\psi_i,

where $u_h$ is known as the trial function that defines the finite element discretization, $u
\approx u_h = \sum_{j=1}^N u_j \phi_j$, with $\phi_j$ being the basis functions.

The Jacobian, which is the derivative of [weak-form] with respect to $u_j$
$\left(\frac{\partial (.)}{\partial u_j}\right)$, is defined as:

!equation id=jacobian
(\nabla \phi_j, \nabla \psi_i)\quad \forall\,\psi_i

As mentioned, the `computeQpResidual` method must be overridden for both flavors of kernels non-AD
and AD. The `computeQpResidual` method for the non-AD version, [`Diffusion`](/Diffusion.md), is
provided in [non-ad-residual].

!listing framework/src/kernels/Diffusion.C id=non-ad-residual
         re=Real\nDiffusion::computeQpResidual.*?}
         caption=The C++ weak-form residual statement of [weak-form] as implemented in the Diffusion kernel.

This object also overrides the `computeQpJacobian` method to define Jacobian term of [jacobian] as
shown in [non-ad-jacobian].


!listing framework/src/kernels/Diffusion.C id=non-ad-jacobian
         re=Real\nDiffusion::computeQpJacobian.*?}
         caption=The C++ weak-form Jacobian statement of [jacobian] as implemented in the Diffusion kernel.


The AD version of this object, [`ADDiffusion`](/ADDiffusion.md), relies on an optimized kernel object
(see [#optimized]), as such it overrides `precomputeQpResidual` as follows.

!listing framework/src/kernels/ADDiffusion.C id=ad-residual
         re=ADDiffusion::precomputeQpResidual.*?}
         caption=The C++ pre-computed portions of the weak-form residual statement of [weak-form] as implemented in the ADDiffusion kernel.


## Time Derivative Kernels

You can create a time-derivative term/kernel by subclassing `TimeKernel` instead of `Kernel`.  For
example, the residual contribution for a time derivative term is:

!equation
\left(\frac{\partial u_h}{\partial t}, \psi_i\right)

where $u_h$ is the finite element solution, and

!equation id=time-derivative
\frac{\partial u_h}{\partial t}
\equiv
\frac{\partial}{\partial t}
\left(
    \sum_k u_k \phi_k
\right)
= \sum_k \frac{\partial u_k}{\partial t} \phi_k

because you can interchange the order of differentiation and summation.

In the equation above, $\frac{\partial u_k}{\partial t}$ is the time derivative of the $k$th finite
element coefficient of $u_h$. While the exact form of this derivative depends on the time stepping
scheme, without much loss of generality, we can assume the following form for the time derivative:

!equation
\frac{\partial u_k}{\partial t} = a u_k + b

for some constants $a$, $b$ which depend on $\Delta t$ and the timestepping method.

The derivative of equation [time-derivative] with respect to $u_j$ is then:

!equation
\frac{\partial}{\partial u_j} \left(
    \sum_k \frac{\partial u_k}{\partial t} \phi_k
\right) =
\frac{\partial }{\partial u_j} \left(
    \sum_k (a u_k + b) \phi_k
\right)
 = a \phi_j

So that the Jacobian term for equation [time-derivative] is

!equation
\left(a \phi_j, \psi_i\right)

where $a$ is what we call `du_dot_du` in MOOSE.

Therefore the `computeQpResidual()` function for our time-derivative term kernel looks like:

```cpp
return _test[_i][_qp] * _u_dot[_qp];
```

And the corresponding `computeQpJacobian()` is:

```cpp
return _test[_i][_qp] * _phi[_j][_qp] * _du_dot_du[_qp];
```

## Coupling with Scalar Variables

If the weak form has contributions from scalar variables, then this contribution can be
treated similarly as coupling from other spatial variables. See the
[`Coupleable`](source/interfaces/Coupleable.md) interface for how to obtain the variable
values. Residual contributions are simply added to the `computeQpResidual()` function.
Jacobian terms from the test spatial variable and incremental scalar variable are added by
overriding the function `computeQpOffDiagJacobianScalar()`.

Contributions to the scalar variable weak equation (test scalar variable terms) are not
natively treated by the `Kernel` class. Inclusion of these residual and Jacobian contributions
are discussed within [`ScalarKernels`](syntax/ScalarKernels/index.md) and specifically
[`KernelScalarBase`](source/kernels/KernelScalarBase.md).

## Further Kernel Documentation

Several specialized kernel types exist in MOOSE each with useful functionality.  Details for each are
in the sections below.

!syntax list /Kernels objects=True actions=False subsystems=False
