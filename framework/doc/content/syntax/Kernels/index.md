# Kernels System

A "Kernel" is a piece of physics. It can represent one or more operators or terms in the weak form of
a partial differential equation.  With all terms on the left-hand-side, their sum is referred to as
the "residual". The residual is evaluated at several integration quadrature points over the problem
domain. To implement your own physics in MOOSE, you create your own kernel by subclassing the MOOSE
`Kernel` class.

In a `Kernel` subclass the `computeQpResidual()` function +must+ be overridden.  This is where you
implement your PDE weak form terms.  The following member functions can
optionally be overridden:

- `computeQpJacobian()`
- `computeQpOffDiagJacobian()`

These two functions provide extra information that can help the numerical solver(s) converge faster
and better.  Inside your Kernel class, you have access to several member variables for computing the
residual and Jacobian values in the above mentioned functions:

- `_i`, `_j`: indices for the current test and trial shape functions respectively.
- `_qp`: current quadrature point index.
- `_u`, `_grad_u`: value and gradient of the variable this Kernel operates on;
  indexed by `_qp` (i.e. `_u[_qp]`).
- `_test`, `_grad_test`: value ($\psi$) and gradient ($\nabla \psi$) of the
  test functions at the q-points; indexed by `_i` and then `_qp` (i.e., `_test[_i][_qp]`).
- `_phi`, `_grad_phi`: value ($\phi$) and gradient ($\nabla \phi$) of the
    trial functions at the q-points; indexed by `_j` and then `_qp` (i.e., `_phi[_j][_qp]`).
- `_q_point`: XYZ coordinates of the current quadrature point.
- `_current_elem`: pointer to the current element being operated on.

## Custom Kernel Creation

To create a custom kernel, you can follow the pattern of the [`Diffusion`](/Diffusion.md) kernel
implemented and included in the MOOSE framework.  Additionally,
[Example 2](examples/custom_kernel.md) provides a step-by-step overview of creating your own custom
kernel.

The strong-form of the diffusion equations is defined on a 3-D domain $\Omega$ as: find $u$ such
that

\begin{equation}
\label{strong-form}
\begin{aligned}
-\nabla\cdot\nabla u - f &= 0 \in \Omega\\
u|_{\partial\Omega_1} &= g_1\\
\nabla u\cdot \hat{n} |_{\partial\Omega_2} &= g_2,
\end{aligned}
\end{equation}
where $\partial\Omega_1$ is defined as the boundary on which the value of $u$ is fixed to a known
constant $g_1$, $\partial\Omega_2$ is defined as the boundary on which the flux across the boundary
is fixed to a known constant $g_2$, and $\hat{n} is the boundary outward normal.

The weak form is generated by multiplying by a test function ($\psi_i$) and integrating over the
domain (using inner-product notation):

\begin{equation}
(-\nabla\cdot\nabla u_h, \psi_i) - (f, \psi_i) = 0\quad \forall\,\psi_i
\end{equation}

and then integrating by parts which gives the weak form:

\begin{equation}
\label{weak-form}
(\nabla u_h, \nabla \psi_i) - (f, \psi_i) - \langle g_2, \psi_i\rangle = 0\quad \forall\,\psi_i,
\end{equation}
where $u_h$ is known as the trial function that defines the finite element discretization, $u
\approx u_h = \sum_{j=1}^N u_j \phi_j$, with $\phi_j$ being the basis functions.

The Jacobian, which is the derivative of [weak-form] with respect to $u_j$
$\left(\frac{\partial (.)}{\partial u_j}\right)$, is defined as:

\begin{equation}
(\nabla \phi_j, \nabla \psi_i)\quad \forall\,\psi_i
\end{equation}

The diffusion kernel header and implementation files are:

!listing framework/include/kernels/Diffusion.h max-height=400px

!listing framework/src/kernels/Diffusion.C max-height=400px

Before a custom physics kernel is available for use, it must be registered in your application.  This
is done in e.g. `src/base/YourApp.C` for the YourApp application.

```cpp
// src/base/YourApp.C contents

#include "YourKernel.h"

...

int YourApp::registerObjects(Factory & factory)
{
  ...
  registerKernel(YourKernel);
  ...
}

...
```


## Time Derivative Kernels

You can create a time-derivative term/kernel by subclassing `TimeKernel` instead of `Kernel`.  For
example, the residual contribution for a time derivative term is:

\begin{equation}
\left(\frac{\partial u_h}{\partial t}, \psi_i\right)
\end{equation}

where $u_h$ is the finite element solution, and

\begin{equation}
\label{time-derivative}
\frac{\partial u_h}{\partial t}
\equiv
\frac{\partial}{\partial t}
\left(
    \sum_k u_k \phi_k
\right)
= \sum_k \frac{\partial u_k}{\partial t} \phi_k
\end{equation}

because you can interchange the order of differentiation and summation.

In the equation above, $\frac{\partial u_k}{\partial t}$ is the time derivative of the $k$th finite
element coefficient of $u_h$. While the exact form of this derivative depends on the time stepping
scheme, without much loss of generality, we can assume the following form for the time derivative:

\begin{equation}
\frac{\partial u_k}{\partial t} = a u_k + b
\end{equation}

for some constants $a$, $b$ which depend on $\Delta t$ and the timestepping method.

The derivative of equation [time-derivative] with respect to $u_j$ is then:

\begin{equation}
\frac{\partial}{\partial u_j} \left(
    \sum_k \frac{\partial u_k}{\partial t} \phi_k
\right) =
\frac{\partial }{\partial u_j} \left(
    \sum_k (a u_k + b) \phi_k
\right)
 = a \phi_j
\end{equation}

So that the Jacobian term for equation [time-derivative] is

\begin{equation}
\left(a \phi_j, \psi_i\right)
\end{equation}

where $a$ is what we call `du_dot_du` in MOOSE.

Therefore the `computeQpResidual()` function for our time-derivative term kernel looks like:

text
```cpp
return _test[_i][_qp] * _u_dot[_qp];
```

And the corresponding `computeQpJacobian()` is:

```cpp
return _test[_i][_qp] * _phi[_j][_qp] * _du_dot_du[_qp];
```

## Further Kernel Documentation

Several specialized kernel types exist in MOOSE each with useful functionality.  Details for each are
in the sections below.

!syntax list /Kernels objects=True actions=False subsystems=False
