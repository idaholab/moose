#* This file is part of the MOOSE framework
#* https://www.mooseframework.org
#*
#* All rights reserved, see COPYRIGHT for full restrictions
#* https://github.com/idaholab/moose/blob/master/COPYRIGHT
#*
#* Licensed under LGPL 2.1, please see LICENSE for details
#* https://www.gnu.org/licenses/lgpl-2.1.html

from collections import namedtuple

class TestStatus(object):
    """
    Class for handling all possible test statuses.
    Every status that is NOT 'no_status' is a Finished status.
    """

    test_status = namedtuple('status', 'status color code')
    no_status = test_status(status='NA', color='GREY', code=0x0)
    success = test_status(status='OK', color='GREEN', code=0x0)
    skip = test_status(status='SKIP', color='GREY', code=0x0)
    silent = test_status(status='SILENT', color='GREY', code=0x0)

    # Unrecoverable
    fail = test_status(status='FAIL', color='RED', code=0x80)
    diff = test_status(status='DIFF', color='YELLOW', code=0x81)
    deleted = test_status(status='DELETED', color='RED', code=0x83)

    __passing_statuses = set([success])
    __failing_statuses = set([fail, diff, deleted])
    __skipped_statuses = set([skip, silent, deleted])
    __silent_statuses = set([silent, deleted])

    def __init__(self, options, status=no_status):
        self.options = options
        self.__status = status
        self.__message = ''

    def setStatus(self, status, message=''):
        """ Set a tester status with optional message """

        self.__status = status

        # Use status identifing string as the message if none supplied
        if not message:
            message = status.status
        self.__message = message

        return self.__status

    def getStatus(self):
        return self.__status

    def createStatus(self):
        """ return a compatible status tuple """
        return self.test_status

    def getStatusMessage(self):
        """ return what ever current message is set """
        return self.__message

    def getColor(self):
        """ return what color should be used to print current status """
        return self.__status.color

    def getStatusCode(self):
        """ return tester status code """
        return self.__status.code

    def isNoStatus(self):
        """ boolean initialized status """
        return self.__status == self.no_status

    def isSilent(self):
        """ boolean for statuses which cause a test to be silent """
        if self.options.extra_info and self.isDeleted():
            pass
        elif (not self.options.report_skipped and self.isSkip()
              or self.__status in self.__silent_statuses):
            return True
        return False

    def isDeleted(self):
        """ boolean deleted status """
        return self.__status == self.deleted

    def isDiff(self):
        """ boolean failed diff status """
        return self.__status == self.diff

    def isFail(self):
        """ boolean for statuses which causes a test to fail """
        return not self.isSilent() and self.__status in self.__failing_statuses

    def isPass(self):
        """ boolean passing status """
        return self.__status in self.__passing_statuses

    def isSkip(self):
        """ boolean for statuses which cause a test to be skipped """
        return (self.__status in self.__skipped_statuses
                and self.__status not in self.__passing_statuses.union(self.__failing_statuses))

    def isFinished(self):
        """ boolean finished status """
        return not self.isNoStatus()

class JobStatus(object):
    """ Class for handling all possible job statuses """

    job_status = namedtuple('status', 'status color code')

    ## Active Statuses ##
    # All jobs begin with the holding status
    hold  = job_status(status='HOLD', color='CYAN', code=0x0)

    # Jobs that are queued, are jobs which have been deemed runnable and have been
    # asynchronously submitted to the multi-threading pool. They can not be 'un-queued'
    # and will begin work, as soon as an available thread(s) becomes ready.
    queued  = job_status(status='QUEUED', color='CYAN', code=0x0)

    # Jobs which are currently consuming slot(s)
    running  = job_status(status='RUNNING', color='CYAN', code=0x0)

    ## The following statuses are finished status types for the name implied ##
    skip  = job_status(status='SKIP', color='GREY', code=0x0)

    # Unrecoverable Finished Statuses
    crash  = job_status(status='CRASH', color='RED', code=0x80)
    error  = job_status(status='ERROR', color='RED', code=0x80)

    # Recoverable Finished Statuses
    timeout  = job_status(status='TIMEOUT', color='RED', code=0x1)

    # The finished status encompasses all above finished statuses including itself
    # A job can specifically be set to 'finished', which basically implies the job
    # was scheduled, and then exited, with no errors generated by the scheduler.
    finished  = job_status(status='FINISHED', color='GREY', code=0x0)

    def __init__(self, status=hold):
        self.__status = status
        self.__message = ''

    def setStatus(self, status, message=''):
        """ Set a job status with optional message """

        # Protect a finished job status (for sanity reasons)
        if self.isFinished():
            return self.__status

        self.__status = status
        self.__message = message
        return self.__status

    def getStatus(self):
        """ return job status """
        return self.__status

    def getStatusMessage(self):
        """ return what ever current message is set """
        return self.__message

    def getStatusCode(self):
        """ return job status code """
        return self.__status.code

    def getColor(self):
        """ return what color should be used to print current status """
        return self.__status.color

    def isHold(self):
        """ boolean holding status """
        return self.__status == self.hold

    def isQueued(self):
        """ boolean queued status """
        return self.__status == self.queued

    def isRunning(self):
        """ boolean running status """
        return self.__status == self.running

    def isTimeout(self):
        """ boolean timeout status """
        return self.__status == self.timeout

    def isCrash(self):
        """
        boolean for "everything was cool up until it wasn't"

        Failures involving external factors that may have caused
        the scheduler to kill the job prematurely.
        """
        return self.__status == self.crash

    def isError(self):
        """
        boolean for scheduler specific errors.

        Populating the DAG incorrectly, race conditions, fall
        under this category.
        """
        return self.__status == self.error

    def isSkip(self):
        """ return bool on skipped status """
        return self.__status == self.skip

    def isPass(self):
        """
        Superficial boolean status on a job that is finished,
        but not failing: The job entered the scheduler and left
        with out generating an error.

        This does not mean, the final TEST has passed. See the
        TestStatus class above for those specific statuses.
        """
        return self.__status == self.finished and not self.isFail()

    def isFail(self):
        """
        boolean for a general failure while attempting to schedule
        a job. Encompasses all job failures. See isError and
        isCrash above for more information.
        """
        return self.__status == self.error or self.__status == self.crash or self.__status == self.timeout

    def isFinished(self):
        """
        boolean for jobs which have a protected finalized status and
        will not be allowed back in the queue. The job may, or may
        not have run successfully. See isPass an isFail.
        """
        return self.isSkip() or self.isPass() or self.isFail()
