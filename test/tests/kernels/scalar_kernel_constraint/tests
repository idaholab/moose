[Tests]
  issues = '#22174'
  design = 'source/kernels/ScalarLMKernel.md'
  [kernel]
    type = 'Exodiff'
    input = 'scalar_constraint_kernel.i'
    exodiff = 'scalar_constraint_kernel_out.e'
    # This problem only has 4 elements and therefore does not seem to run on > 4 procs.
    max_parallel = 4
    # The true solution and l2_err for this test are nearly zero, so don't use relative differences to compare them.
    abs_zero = 1e-9
    requirement = 'The system shall solve a constrained Neumann problem and volume averaging using the Lagrange multiplier approach derived from a scalar augmentation class.'
  []

  [kernel_LU]
    type = 'CSVDiff'
    input = 'scalar_constraint_kernel_LU.i'
    csvdiff = 'scalar_constraint_kernel_LU_out.csv'
    # This problem only has 4 elements and therefore does not seem to run on > 4 procs.
    max_parallel = 4
    requirement = 'The system shall solve the constrained Neumann problem using the Lagrange multiplier approach with an LU solver.'
  []

  [bipass]
    type = 'CSVDiff'
    input = 'diffusion_bipass_scalar.i'
    csvdiff = 'diffusion_bipass_scalar_out.csv'
    # This problem only has 4 elements and therefore does not seem to run on > 4 procs.
    max_parallel = 4
    requirement = 'The system shall support the ability to include the scalar wrapper but not actually use a scalar variable.'
  []

  [override]
    type = RunException
    input = 'diffusion_override_scalar.i'
    expect_err = 'A scalar_variable has been set and compute_scalar_residuals=true, but the computeScalarQpResidual method was not overridden. Accidental call of base class?'
    requirement = 'The system shall error if a derived object uses scalars and computes scalar residuals but does not override the quadrature point residual calculation routine.'
  []
[]
