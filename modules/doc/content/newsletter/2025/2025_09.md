# MOOSE Newsletter (September 2025)

## MOOSE Improvements

### Preliminary Kokkos-MOOSE release

A new GPU backend, [Kokkos](https://kokkos.org/), was added in MOOSE and is available for preliminary testing with NVIDIA GPUs. Kokkos-MOOSE provides programming and user interfaces that are designed to resemble the original MOOSE interfaces to make adaptation easier and reduce porting efforts. Kokkos-MOOSE currently supports the GPU version of [Kernels](syntax/KokkosKernels/index.md), [NodalKernels](syntax/KokkosNodalKernels/index.md), [BCs](syntax/KokkosBCs/index.md), and [Materials](syntax/KokkosMaterials/index.md) and will be continuously extended to incorporate more MOOSE capabilities and support more GPU vendors. See [this page](getting_started/installation/install_kokkos.md) to get started with Kokkos-MOOSE.

### TestHarness `--only-tests-that-require` option

The `capability` parameter for test specifications allows for run-time checking of if a test can or cannot run based on capabilities defined by the application executable. The `--only-tests-that-require` command line option has been added to the [TestHarness.md], which allows filtering of tests based on whether or not they depend on a capability.

For example, take a situation in which `./run_tests --only-tests-that-require cuda` is ran along with the following test specification:

```
[Tests]
  [needs_cuda]
    ...
    capabilities = 'cuda'
  []
  [doesnt_need_cuda]
    ...
    capabilities = 'libtorch'
  []
[]
```

In this case, the test `needs_cuda` will be ran beacuse it depends on the `cuda` capability, while the `doesnt_need_cuda` test will not run because it does not depend on the `cuda` capability.

### Optimizations

Face material properties are now only computed if the boundary conditions, interface kernels and/or constraints
active on the relevant boundary have requested material properties.

The logic for deciding whether to execute on internal sides for DG and HDG kernels was reworked to limit queries
in the dedicated warehouses within each subdomain.

The expected computational cost reduction for each simulation is highly dependent on the set of active features and the cost repartition. Use [profiling](profiling.md) to determine the computational cost repartition.


## MOOSE Modules Changes

### Solid mechanics

The [ReactionForceAux.md] was added to leverage the [TaggingInterface.md] to output the forces, as applied
when computing the residual, at the desired nodes.

### Contact

The [PenetrationLocator.md] was upgraded to be able to support finding elements near contact nodes that are not
connected to these nodes. This may notably occur when using FlexIGA.

### Fluid Structure Interaction

The Newmark-Beta time integration scheme can now be used in Arbitrary Lagrangian Eulerian (ALE) simulations.
New interface kernels enforce continuity of flux and continuity of the solution via the penalty method across an interface with the solid velocity computed using the Newmark-Beta method.

### Phase field

A set of kernels was added to solve the phase field equations coupled with the Navier Stokes equations for advection.
This is notably used for multiphase flow, as it involves the coupling of phase tracking algorithms with the
Navier-Stokes equations. The advantage of using the phase field method for this coupling is that it does not require the
explicit calculation of the interface.

## libMesh-level Changes

### `2025.09.18` Update

- Limited support for untangling of tangled meshes in `VariationalMeshSmoother`
- Support for smoothing meshes including pyramids with `VariationalMeshSmoother`
- Added `SparseMatrix::read_coreform_hdf5()` method for reading CSR sparse matrix data from an HDF5-based format
- Default to syncing C++ streams for more reliable console output in cases like threaded output
- Made `libMesh::out` and `libMesh::err` thread-safe even when emitting non-ASCII (unicode, color codes) output
- Made `prepare_for_use()` optional after mesh stitching.  This will enable much faster parallel generation of complex meshes in certain MOOSE workflows.
- Added optional parameter to `build_side_list_from_node_list()` to allow only some nodesets to be converted rather than all
- Added `Parameters::Value::type_info()` method
- Updated autotools to their latest versions.  This fixes a linker bug that was preventing libMesh compilation with some newer software stacks.
- Use `MatGetValue` instead of `MatGetRow` in `PetscMatrix::operator()`, to improve compatibility and efficiency
- `PerfLog` performance logging of Netgen tetrahedralization
- Bug fixes for parallel `StaticCondensation` operation
- Bug fix for certain use cases of `PetscVector` constructed directly from PETSc `Vec`
- Bug fix for triangulation of boundaries with quadratic edges
- Bug fix for an adaptive refinement failure case on distributed meshes
- Fixed handling of linearly-dependent data in reduced basis EIM training
- Fixed small `PetscViewer` memory leaks in `print_matlab()` methods

## PETSc-level Changes

## Bug Fixes, Minor Changes, and Minor Enhancements

- [PythonFMU](https://github.com/NTNU-IHB/PythonFMU) has been added to the `moose-dev` container using GCC.
- Added an Intel LLVM compiler container option.
- A [GenericConstantStdVectorMaterial.md] was added to use `std::vector<Real>` properties
- Direct output of `std::vector<Real>` properties, using the `outputs=...` parameter, was added
- The [SideSetsFromNodeSetsGenerator.md] was extended to support converting only a selection of nodesets.
- The [ADScaledCoupledTimeDerivative.md] was added to the framework to serve as the coupled time derivative kernel with an option for a scaling factor. At this time, only `ADReal`-valued material properties can be used as scaling factors.
- [ConservativeAdvection.md] can now use the gradient of a variable as the advecting velocity.
- An AD-version of the [ConservativeAdvectionBC.md] was added
- The [ElementAdaptivityLevelAux.md] was added to output the level of h- or p-refinement of each element.
- Scalar variables can now be used as `ADReal`-valued functors. This greatly expands the number of objects that can
  accept scalar variables as inputs. The use of AD notably helps computing a numerically exact Jacobian.
- The [FunctorKernel.md] was expanded to simplify setting up the equation `u = <a functor>` in a single kernel.


## Conda Package Changes
