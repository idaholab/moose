# MOOSE Newsletter (September 2025)

## MOOSE Improvements

### Preliminary Kokkos-MOOSE release

A new GPU backend, [Kokkos](https://kokkos.org/), was added in MOOSE and is available for preliminary
testing with NVIDIA GPUs. Kokkos-MOOSE provides programming and user interfaces that are designed to
resemble the original MOOSE interfaces to make adaptation easier and reduce porting efforts. Kokkos-MOOSE
currently supports the GPU version of [Kernels](syntax/KokkosKernels/index.md), [NodalKernels](syntax/KokkosNodalKernels/index.md),
[BCs](syntax/KokkosBCs/index.md), and [Materials](syntax/KokkosMaterials/index.md) and will be continuously
extended to incorporate more MOOSE capabilities and support more GPU vendors. See [this page](getting_started/installation/install_kokkos.md)
to get started with Kokkos-MOOSE.

### TestHarness `--only-tests-that-require` option

The `capability` parameter for test specifications allows for run-time checking of whether a test can
or cannot run based on capabilities defined by the application executable. The `--only-tests-that-require`
command line option has been added to the [TestHarness.md], which allows filtering of tests based on
whether or not they depend on a capability.

For example, take a situation in which `./run_tests --only-tests-that-require cuda` is run along with
the following test specification:

```
[Tests]
  [needs_cuda]
    ...
    capabilities = 'cuda'
  []
  [doesnt_need_cuda]
    ...
    capabilities = 'libtorch'
  []
[]
```

In this case, the test `needs_cuda` will be run because it depends on the `cuda` capability, while
the `doesnt_need_cuda` test will not run because it does not depend on the `cuda` capability.

### Optimizations

Face and neighbor face material properties are now only computed if the boundary conditions and interface kernels active on the
relevant boundary have requested material properties, or if any active constraint has requested a material property. The logic for deciding
whether to execute on internal sides for DG and HDG kernels was reworked to limit queries in the dedicated
warehouses within each subdomain. The expected computational cost reduction for each simulation is
highly dependent on the set of active features and the cost repartition. Use [profiling](profiling.md)
to determine the computational cost repartition.

## MOOSE Modules Changes

### Solid mechanics

The [ReactionForceAux.md] was added to leverage the [TaggingInterface.md] to output the forces, as
applied when computing the residual, at the desired nodes.

### Contact

The [PenetrationLocator.md] was upgraded to be able to support finding
elements that are proximal to but not connected to these nodes.  This
may occur on non-conforming surface meshes, such as Flex IGA meshes or
3D meshes with hanging nodes from adaptive refinement.

Objects based on the `GeometricSearchInterface` still default to the
old `search_method=nearest_node_connected_sides`, which only finds
paired points on sides connected to the nearest node to a queried
point, but with the new `search_method=all_proximate_sides` option,
contact and gap objects can instead use the point locator octree to
test all sides touching a point.

### Fluid Structure Interaction

The Newmark-Beta time integration scheme can now be used in Arbitrary Lagrangian Eulerian (ALE)
simulations. New interface kernels enforce continuity of flux and continuity of the solution via the
penalty method across an interface with the solid velocity computed using the Newmark-Beta method.

### Phase field

A set of kernels was added to solve the phase field equations coupled with the Navier-Stokes equations
for advection. This is notably used for multiphase flow, as it involves the coupling of phase tracking
algorithms with the Navier-Stokes equations. The advantage of using the phase field method for this
coupling is that it does not require the explicit calculation of the interface.

## libMesh-level Changes

### `2025.09.18` Update

- Limited support for untangling of tangled meshes in `VariationalMeshSmoother`
- Support for smoothing meshes including pyramids with `VariationalMeshSmoother`
- Added `SparseMatrix::read_coreform_hdf5()` method for reading CSR sparse matrix data from an HDF5-based
  format
- Default to syncing C++ streams for more reliable console output in cases like threaded output
- Made `libMesh::out` and `libMesh::err` thread-safe even when emitting non-ASCII (unicode, color
  codes) output
- Made `prepare_for_use()` optional after mesh stitching.  This will enable much faster parallel
  generation of complex meshes in certain MOOSE workflows.
- Added optional parameter to `build_side_list_from_node_list()` to allow only some nodesets to be
  converted rather than all
- Added `Parameters::Value::type_info()` method
- Updated autotools to their latest versions.  This fixes a linker bug that was preventing libMesh
  compilation with some newer software stacks.
- Use `MatGetValue` instead of `MatGetRow` in `PetscMatrix::operator()`, to improve compatibility and
  efficiency
- `PerfLog` performance logging of Netgen tetrahedralization
- Bug fixes for parallel `StaticCondensation` operation
- Bug fix for certain use cases of `PetscVector` constructed directly from PETSc `Vec`
- Bug fix for triangulation of boundaries with quadratic edges
- Bug fix for an adaptive refinement failure case on distributed meshes
- Fixed handling of linearly-dependent data in reduced basis EIM training
- Fixed small `PetscViewer` memory leaks in `print_matlab()` methods

## Bug Fixes, Minor Changes, and Minor Enhancements

- [PythonFMU](https://github.com/NTNU-IHB/PythonFMU) has been added to the `moose-dev` container using
  GCC.
- Added an Intel LLVM compiler container option.
- A [GenericConstantStdVectorMaterial.md] was added to use `std::vector<Real>` properties.
  It is modeled after the [GenericConstantVectorMaterial.md]. The `GenericConstantRealVectorValue` has been deprecated.
- Direct output of `std::vector<Real>` properties, using the `outputs=...` parameter, was added
- The [SideSetsFromNodeSetsGenerator.md] was extended to support converting only a selection of nodesets.
- The [ADScaledCoupledTimeDerivative.md] was added to the framework to serve as the coupled time
  derivative kernel with an option for a scaling factor. At this time, only `ADReal`-valued material
  properties can be used as scaling factors.
- [ConservativeAdvection.md] can now use the gradient of a variable as the advecting velocity.
- An AD-version of the [ConservativeAdvectionBC.md] was added
- The [ElementAdaptivityLevelAux.md] was added to output the level of h- or p-refinement of each element.
- Scalar variables can now be used as `ADReal`-valued functors. This greatly expands the number of
  objects that can accept scalar variables as inputs. The use of AD notably helps computing a numerically
  exact Jacobian.
- The [FunctorKernel.md] was expanded to simplify setting up the equation `u = <a functor>` in a single
  kernel.
