# * This file is part of the MOOSE framework
# * https://mooseframework.inl.gov
# *
# * All rights reserved, see COPYRIGHT for full restrictions
# * https://github.com/idaholab/moose/blob/master/COPYRIGHT
# *
# * Licensed under LGPL 2.1, please see LICENSE for details
# * https://www.gnu.org/licenses/lgpl-2.1.html

import enum
import os
import copy
from collections import OrderedDict
from dataclasses import dataclass, field
from logging import getLogger
from typing import Optional, Callable, Iterable, Generator

import numpy as np

import pyhit
from moosecontrol import MooseControl, SubprocessPortRunner

logger = getLogger("StochasticControl")


@dataclass
class StochasticRunOptions:
    """Options for running with the Stochastic Tools Module

    Parameters:
        num_procs (int): The number of processors to run with (default=1).
        mpi_command (str): Command for MPI execution (default='mpiexec').
        input_name (str): Name of the input file which will be generated by
                          StochasticControl (default='stochastic_run.i')
        cli_args (list[str]): List of additional command-line arguments to
                              provide at execution.
        min_procs_per_sample (int): See documentation for
                                    MultiApps/SamplerFullSolveMultiApp/min_procs_per_app.
        multiapp_mode (MultiAppMode): See documentation for
                                      StochasticRunOptions.MultiAppMode
                                      (default=BATCH_RESET).
        ignore_solve_not_converge (bool): Whether or not to continue sampling
                                          if a solve fails (default=False).
    """

    class MultiAppMode(enum.IntEnum):
        """Enumeration of mode of stochastic execution.
        See "Execution Mode" section of ParameterStudy syntax documentation for
        equivalent details.
        """

        NORMAL = 0
        BATCH_RESET = 1
        BATCH_RESTORE = 2
        BATCH_KEEP_SOLUTION = 3
        BATCH_NO_RESTORE = 4

        @property
        def mode(self) -> str:
            """Mode string to send to multi-app parameter."""
            if self.value == 0:
                return "normal"
            elif self.value == 1:
                return "batch-reset"
            else:
                return "batch-restore"

        @property
        def is_restore(self) -> bool:
            """Whether or not this is in 'restore' mode.
            Facilitates how parameters are transferred to sub-application.
            """
            return self.value > 1

    num_procs: int = 1
    mpi_command: str = "mpiexec"
    input_name: str = "stochastic_run.i"
    cli_args: list[str] = field(default_factory=list)
    min_procs_per_sample: int = None
    multiapp_mode: MultiAppMode = MultiAppMode.BATCH_RESET
    ignore_solve_not_converge: bool = False


DEFAULT_OPTIONS = StochasticRunOptions()


class StochasticControl(MooseControl):
    """
    A MOOSE control interface for executing stochastic sampling runs
    using the StochasticTools module.

    This class automates the setup of input files, execution, and retrieval
    of results (quantities of interest, QoIs) based on sampled parameters.

    Example Usage::

        from moose_stochastic_tools import StochasticControl, StochasticRunOptions

        executable = '...' # Path to MOOSE executable with STM enabled
        input_file = 'physics.i'
        params = [...] # Parameters in physics input to modify
        qois = [...] # Reporter value names to retrieve after running the physics input
        opts = StochasticRunOptions(num_procs=<n>)
        with StochasticControl(executable, input_file, params, qois, opts) as runner:
            while sampling:
                x = ... # Produce sampling matrix
                y = runner(x) # Retrieve results

    Attributes:
        sampler_name: The name of the sampler block.
        web_server_control_name: Name used for web server-based control.
        multiapp_name: Name for the multiapp runner.
        sample_receiver_name: Control block name for parameter receivers.
        parameter_transfer_name: Name for parameter transfer/control block.
        qoi_storage_name: Name of the reporter storing QoIs.
        qoi_transfer_name: Name of the transfer block for QoIs.
        controllable_matrix: The path to the sampler matrix block.
    """

    # Object names for the input
    sampler_name = "sample"
    web_server_control_name = "matrix_control"
    multiapp_name = "runner"
    sample_receiver_name = "parameter_receiver"
    parameter_transfer_name = "param"
    qoi_storage_name = "storage"
    qoi_transfer_name = "data"
    controllable_matrix = f"Samplers/{sampler_name}/matrix"

    def __init__(
        self,
        executable: str,
        physics_input: str,
        parameters: list[str],
        quantities_of_interest: list[str],
        options: StochasticRunOptions = DEFAULT_OPTIONS,
        physics_cli_args: list[str] = [],
        keep_input: bool = False,
        moose_port: int = None,
        poll_time: float = 0.1,
    ):
        """
        Initialize the StochasticControl object with executable, input and control options.

        1. Builds a pyhit.Node ready to be written to a file once sampling starts
        2. Constructs MOOSE command to be sent to base class so server will start.

        Parameters:
            executable (str): Path to the MOOSE executable.
            physics_input (str): Filename of the physics simulation input.
            parameters (list[str]): List of parameter names to sample.
            quantities_of_interest (list[str]): List of QoI reporter names to collect.
            options (StochasticRunOptions): Stochastic run configuration options.
            physics_cli_args (list[str]): Additional CLI arguments for the physics app.
            keep_input (bool): True to not automatically delete the
                               auto-generated stochastic input (default = False)
            moose_port (int): Optional port number for web server control.
            poll_time (float): Polling time interval for checking MOOSE status.
        """
        self.physics_input: str = physics_input
        self._parameters: list[str] = parameters
        self.num_params: int = self._getNumParams(parameters)
        self._qois: list[str] = quantities_of_interest
        self.num_qois: int = len(self._qois)
        self._opt: StochasticRunOptions = options
        self._physics_cli_args: list[str] = physics_cli_args
        self._input_file = os.path.abspath(self._opt.input_name)
        self._keep_input: bool = keep_input

        # Build stochastic input
        self._root: pyhit.Node = self._buildStochasticInput()

        # Determine command
        moose_command: list[str] = []
        if self._opt.num_procs > 1:
            moose_command += [self._opt.mpi_command, "-n", str(self._opt.num_procs)]
        moose_command += [executable, "-i", self._opt.input_name]
        moose_command += self._opt.cli_args

        # Initialize runner for base class
        runner = SubprocessPortRunner(
            command=moose_command,
            moose_control_name=self.web_server_control_name,
            port=moose_port,
            poll_time=poll_time,
        )
        super().__init__(runner)

    def __enter__(self) -> "StochasticRunner":
        """
        Context manager entry to return a callable `StochasticRunner` object.
        This enables easy usage in `with` blocks.

        Unfortunately, we cannot initialize the simulation here because the run
        needs a proper input matrix for the first time through.

        Returns:
            StochasticRunner: A callable runner instance.
        """
        return StochasticRunner(self)

    def __exit__(self, exc_type=None, exc_value=None, ex_tb=None):
        """
        Clean up after a run by terminating or killing the MOOSE process
        and removing the temporary input file.
        """
        # Terminate gracefully
        if exc_type is None:
            # If moose is waiting, send a terminate
            try:
                waiting_flag = self.get_waiting_flag()
            except:
                waiting_flag = None
            if not waiting_flag is None:
                self.set_terminate()

            # Don't finalize if we never started
            if self.initialized:
                self.finalize()

        # Kill/cleanup the simulation if there was an exception
        else:
            self.cleanup()

        if not self._keep_input and os.path.exists(self._input_file):
            os.remove(self._input_file)

    def setInput(self, x: np.ndarray):
        """
        Set the input parameter matrix to the sampler.

        If we haven't initialized yet, set the matrix directly in the input
        file; otherwise set the controllable value.

        Parameters:
            x: A NumPy array containing parameter values to sample.
        """
        if not self.initialized:
            # If we haven't started yet, the input matrix should be set at input
            self._sampler["matrix"] = "'" + self._matrixToParameter(x) + "'"
        # Simulation is already started
        else:
            self.wait("TIMESTEP_END")
            self.set_realeigenmatrix(self.controllable_matrix, x)

    def run(self):
        """
        Executes the MOOSE simulation.
        If not initialized, writes the input and starts a new simulation;
        otherwise continues execution.
        """
        if not self.initialized:
            # Write file
            logger.debug(
                f"Writing input file: {os.path.abspath(self._input_file)}\n{self._root.render()}"
            )
            pyhit.write(self._input_file, self._root)

            self.initialize()
        else:
            self.set_continue()

    def getVectorOutput(self) -> list:
        """
        Waits for simulation completion and retrieves QoI reporter vector


        Returns:
            A list of lists with shape (num_samples, num_qois, len(qois))
        :rtype: list
        """
        self.wait("TIMESTEP_END")

        y = []
        for qoi in self._qois:
            rep = f"{self.qoi_storage_name}/" + qoi.replace("/", ":")
            y.append(self.get_reporter(rep))
        return y

    def getOutput(self) -> np.ndarray:
        """
        Waits for simulation completion and retrieves QoI reporter values.

        Returns:
            A NumPy array of shape (num_samples, num_qois) with simulation results.
        """
        self.wait("TIMESTEP_END")

        y = []
        all_floats = True  # Determine if we are only gathering scalar quantities
        # Will determine this from the size of the first reporter gathered
        num_samples = None
        for qoi in self._qois:
            rep = f"{self.qoi_storage_name}/" + qoi.replace("/", ":")
            rep_val = self.get_reporter(rep)

            # See if value is list of floats
            assert isinstance(rep_val, list)
            all_floats = all_floats and all(isinstance(v, float) for v in rep_val)

            # Check reporter size
            if num_samples is None:
                num_samples = len(rep_val)
            else:
                assert num_samples == len(rep_val)

            y.append(rep_val)

        # If all reporters are scalar values, then we can return a standard 2-D numpy array
        if all_floats:
            return np.array(y).T
        # Otherwise, we will return a 2-D numpy array of objects
        else:
            arr = np.empty((num_samples, len(y)), dtype=object)
            for n in range(num_samples):
                for q in range(len(y)):
                    arr[n, q] = copy.deepcopy(y[q][n])
            return arr

    def _buildStochasticInput(self) -> pyhit.Node:
        """
        Constructs the input file tree for a stochastic MOOSE run.

        Note that the input file is not written until the first input is passed
        in.

        Returns:
            Root pyhit.Node representing the full input file structure.
        """
        # Build root node
        root = pyhit.Node()

        # Add [StochasticTools]
        self._getSyntaxBlockHelper(root, "StochasticTools")

        self._sampler = self._addDynamicSampler(root)
        self._addWebServerControl(root)
        self._addMultiApp(root)
        if self._opt.multiapp_mode.is_restore:
            self._addParameterTransfer(root)
        else:
            self._addParameterControl(root)
        self._addStochasticMatrix(root)
        self._addQoiTransfer(root)

        # Add [Executioner]
        self._getSyntaxBlockHelper(root, "Executioner")["type"] = "Transient"

        return root

    def _addDynamicSampler(self, parent: pyhit.Node) -> pyhit.Node:
        """
        Adds the InputMatrix sampler object.

        Parameters:
            parent (pyhit.Node): The parent pyhit node to add block to (usually root node of input).

        Returns:
            child (pyhit.Node): Pyhit node of the action block.
        """
        # Get the [Samplers] block if one exists, otherwise create one
        samplers = self._getSyntaxBlockHelper(parent, "Samplers")

        # Create parameters
        sampler_params = {
            "type": "InputMatrix",
            "matrix": "'" + " ".join(["0" for _ in range(self.num_params)]) + "'",
            "execute_on": "'MULTIAPP_FIXED_POINT_BEGIN'",
        }
        # Add additional execute_on for batch-reset
        if not self._opt.multiapp_mode.is_restore:
            sampler_params["execute_on"] = (
                "'PRE_MULTIAPP_SETUP " + sampler_params["execute_on"][1:]
            )
        # Add min_procs if requested
        if not self._opt.min_procs_per_sample is None:
            sampler_params["min_procs_per_row"] = self._opt.min_procs_per_sample

        # Build sampler and return
        return samplers.append(self.sampler_name, **sampler_params)

    def _addWebServerControl(self, parent: pyhit.Node) -> pyhit.Node:
        """Add WebServerControl."""
        controls: pyhit.Node = self._getSyntaxBlockHelper(parent, "Controls")
        return controls.append(
            self.web_server_control_name,
            type="WebServerControl",
            execute_on="'TIMESTEP_END'",
        )

    def _addMultiApp(self, parent: pyhit.Node) -> pyhit.Node:
        """Adds MultiApp for the physics input."""
        multiapps = self._getSyntaxBlockHelper(parent, "MultiApps")
        multiapp_params = {
            "type": "SamplerFullSolveMultiApp",
            "input_files": self.physics_input,
            "sampler": self.sampler_name,
            "mode": self._opt.multiapp_mode.mode,
            "execute_on": "'TIMESTEP_BEGIN'",
        }
        if self._opt.ignore_solve_not_converge:
            multiapp_params["ignore_solve_not_converge"] = "true"
        if not self._opt.min_procs_per_sample is None:
            multiapp_params["min_procs_per_app"] = self._opt.min_procs_per_sample
        if (
            self._opt.multiapp_mode
            == StochasticRunOptions.MultiAppMode.BATCH_KEEP_SOLUTION
        ):
            multiapp_params["keep_solution_during_restore"] = "true"
        if (
            self._opt.multiapp_mode
            == StochasticRunOptions.MultiAppMode.BATCH_NO_RESTORE
        ):
            multiapp_params["no_restore"] = "true"

        # Physics command line arguments
        cli_args = self._physics_cli_args[:]
        if self._opt.multiapp_mode.is_restore:
            cli_args.append(
                f"Controls/{self.sample_receiver_name}/type=SamplerReceiver"
            )
        if cli_args:
            multiapp_params["cli_args"] = "'" + ";".join(cli_args) + "'"

        return multiapps.append(self.multiapp_name, **multiapp_params)

    def _addParameterTransfer(self, parent: pyhit.Node) -> pyhit.Node:
        """Add parameter transfer."""
        transfers = self._getSyntaxBlockHelper(parent, "Transfers")
        return transfers.append(
            self.parameter_transfer_name,
            type="SamplerParameterTransfer",
            to_multi_app=self.multiapp_name,
            sampler=self.sampler_name,
            parameters="'" + " ".join(self._parameters) + "'",
        )

    def _addParameterControl(self, parent: pyhit.Node) -> pyhit.Node:
        """Add multiapp command-line control."""
        controls: pyhit.Node = self._getSyntaxBlockHelper(parent, "Controls")
        return controls.append(
            self.parameter_transfer_name,
            type="MultiAppSamplerControl",
            multi_app=self.multiapp_name,
            sampler=self.sampler_name,
            param_names="'" + " ".join(self._parameters) + "'",
        )

    def _addStochasticMatrix(self, parent: pyhit.Node) -> pyhit.Node:
        """
        Add StochasticMatrix reporter object for output of sampling matrix
        and quantities of interest.
        """
        reporters = self._getSyntaxBlockHelper(parent, "Reporters")
        reporter_params = {
            "type": "StochasticMatrix",
            "parallel_type": "ROOT",
            "sampler": self.sampler_name,
            "execute_on": "'TRANSFER'",
        }
        return reporters.append(
            self.qoi_storage_name,
            **reporter_params,
        )

    def _addQoiTransfer(self, parent: pyhit.Node) -> pyhit.Node:
        """Add SamplerReporterTransfer for QoIs."""
        transfers = self._getSyntaxBlockHelper(parent, "Transfers")
        return transfers.append(
            self.qoi_transfer_name,
            type="SamplerReporterTransfer",
            from_multi_app=self.multiapp_name,
            sampler=self.sampler_name,
            stochastic_reporter=self.qoi_storage_name,
            from_reporter="'" + " ".join(self._qois) + "'",
            prefix="''",
        )

    @staticmethod
    def _getSyntaxBlockHelper(parent: pyhit.Node, syntax: str) -> pyhit.Node:
        """Get a node with inputted syntax, if exists. Otherwise add one."""
        for child in parent:
            if child.name == syntax:
                return child
        return parent.append(syntax)

    @staticmethod
    def _getNumParams(parameters: list[str]) -> int:
        """Get number of parameters from the inputted list."""
        num_params: int = 0
        for param in parameters:
            # Not a vector parameter
            if not "[" in param:
                num_params += 1
            # Vector param
            else:
                # Get entries: "param[0,(3.14),1]" -> ["0", "(3.14)", "1"]
                vector_entries = param.split("[")[1][:-1].split(",")
                # Get the max entry
                for entry in vector_entries:
                    if not "(" in entry:
                        num_params = max(int(entry) + 1, num_params)
        return num_params

    @staticmethod
    def _matrixToParameter(matrix: np.ndarray) -> str:
        """Convert a numpy array to a MOOSE-input matrix."""
        assert len(matrix.shape) == 2
        return "; ".join([" ".join([f"{elem:.16g}" for elem in row]) for row in matrix])


class _ResultCache:
    """
    Lightweight tolerance-aware LRU cache for per-row simulation results.

    Each cache entry maps a single input row (1-D array) to a single output row
    (1-D array of QoIs). Keys are built by binning each coordinate using
    `round(x / tol)`, which groups near-identical inputs into the same bucket.
    To prevent false hits due to bin collisions, a bucket hit is accepted only
    if `np.allclose(a, b, rtol=tol, atol=0.0)` holds.

    Notes:
        - Eviction policy is LRU (least recently used): accessing an entry moves it
          to the "most recent" end; when `maxsize` is exceeded, the oldest entry is
          evicted.
    """

    def __init__(self, maxsize: int = 10000, tol: float = 1e-14):
        """
        Parameters:
            maxsize (int): Maximum number of cached entries (default = 1e5). Must be > 0.
            tol (float):
                Relative tolerance used both for bucketing (via rounding `x / tol`)
                and for equality checks (`np.allclose(..., rtol=tol, atol=0.0)`).
                Must be > 0.
        """
        assert maxsize > 0
        if type(tol) is list:
            assert all([x > 0 for x in tol])
        else:
            assert tol > 0.0
        self.maxsize = maxsize
        self.tol = tol
        self._cache: OrderedDict[tuple[int, ...], tuple[np.ndarray, np.ndarray]] = (
            OrderedDict()
        )

    def _key(self, row: np.ndarray) -> tuple[int, ...]:
        """
        Compute the bucket key for an input row.

        Parameters:
            row (np.ndarray):
                1-D input vector representing a single sample (shape: `(num_params,)`).

        Returns:
            tuple of int
                The integer key obtained by rounding `row / tol` element-wise.

        Notes:
            - Different rows may map to the same key; correctness is enforced by
              `_close` during retrieval.
        """
        return tuple(np.rint(row / self.tol).astype(np.int64).tolist())

    def _close(self, a: np.ndarray, b: np.ndarray) -> bool:
        """
        Check whether two rows are considered equal within tolerance.

        Parameters:
            (a, b) (np.ndarray): Input rows to compare (shape is `(num_params,)`).

        Returns:
            bool
                True if `np.allclose(a, b, rtol=tol, atol=0.0)` is satisfied; False otherwise.
        """
        return np.allclose(a, b, rtol=self.tol, atol=0.0)

    def get(self, x: np.ndarray) -> Optional[np.ndarray]:
        """
        Retrieve a cached output row for a given input row, if present.

        Parameters:
            x (np.ndarray): 1-D input row (shape: `(num_params,)`).

        Returns:
            np.ndarray or None
                Cached output row (shape: `(num_qois,)`) if a tolerance-verified
                hit occurs; otherwise `None`.

        Notes:
            - On a hit, the entry is moved to the most recently used position for LRU accounting.
            - A key match is necessary but not sufficient; a final `_close` check
              guarantees the returned output corresponds to an input within tolerance.
        """
        k = self._key(x)
        x_ref, y_ref = self._cache.get(k, (None, None))
        if not x_ref is None:
            if self._close(x, x_ref):
                self._cache.move_to_end(k)
                return y_ref
        return None

    def set(self, x: np.ndarray, y: np.ndarray):
        """
        Insert or update the cached mapping for an input row.

        Parameters:
            x (np.ndarray): 1-D input row (shape: `(num_params,)`).
            y (np.ndarray): 1-D output row (shape: `(num_qois,)`) to cache.

        Notes:
            - Stores copies of `x` and `y` to avoid accidental external mutation.
            - Marks the entry as most recently used.
            - If `maxsize` is exceeded, evicts the least recently used entry.
            - This method does not perform a tolerance check; it trusts the caller to
            store outputs corresponding to `x`.
        """
        k = self._key(x)
        self._cache[k] = (x.copy(), copy.deepcopy(y))
        if len(self._cache) > self.maxsize:
            self._cache.popitem(False)


class StochasticRunner:
    """
    Callable class that executes the simulation for a given input sample matrix
    and returns the corresponding QoI results.

    This class is designed to be used within a context manager via `StochasticControl`.

    Attributes:
        _control (StochasticControl): Underlying simulation controller.
        _result_cache (_ResultCache): Cache instance; `None` if caching is disabled (default).

    Notes:
        - Caching is optional and configured via `configCache`.
        - Caching is "per row": each input row maps to a cached output row.
        - Duplicate rows within the same call are not deduplicated; both will be
          evaluated unless they are already present in the cache from prior calls.
    """

    def __init__(self, control: StochasticControl):
        """
        Parameters:
            control (StochasticControl): A StochasticControl instance managing MOOSE interaction.
        """
        self._control: StochasticControl = control
        self._result_cache: Optional[_ResultCache] = None

    def parallelWorker(
        self, func: Callable, x_iter: Iterable
    ) -> Generator[np.ndarray | float, None, None]:
        """
        Map-like callable to use as `workers` in SciPy optimizers (emulates
        `multiprocessing.Pool.map`).

        This method is designed to be passed directly as the `workers` argument
        to SciPy routines that accept a map-like callable (e.g.,
        `scipy.optimize.shgo`).

        The idea is to utilize stochastic_tool's parallelism by sending a group
        of samples at once. It does not utilize any python-based parallelism.

        Behavior:
            1. Materializes `x_iter` into a numpy array and ensures the internal
               result cache is enabled and large enough for the batch.
            2. Calls `self(X)` once to precompute and populate the cache for all rows.
               (If your objective calls back into this runner, subsequent lookups are
               cache hits and the underlying control isn't re-run.)
            3. Returns a generator that yields `func(xi)` for each `xi` from
               `x_iter`--i.e., a map-like interface compatible with SciPy's
               `workers` argument.

        Parameters:
            func (Callable):
                The function to apply to each element of `x_iter`. In typical
                use this objective will call back into
                `StochasticRunner.__call__` to obtain QoIs for `xi`.
            x_iter (Iterable): Iterable of inputs (scalars or 1-D arrays).

        Yields:
            yi (np.ndarray or float):
                The result of `func(xi)` for each `xi` in `x_iter`.

        Examples::
            >>> with StochasticControl(...) as runner:
            ...     runner.configCache()
            ...     def objective(x):
            ...         y = runner(x)
            ...         # Return first quantity of interest (column if multiple samples)
            ...         return y[:, 0] if y.ndim > 1 else y[0]
            ...
            ...     from scipy.optimize import shgo
            ...     res = shgo(objective, bounds, workers=runner.parallelWorker)
        """
        x = np.array([xi for xi in x_iter])
        if self._result_cache is None:
            self.configCache(len(x_iter))
        elif self._result_cache.maxsize < x.shape[0]:
            self._result_cache.maxsize = x.shape[0]

        self(x)
        for xi in x_iter:
            yield func(xi)

    def configCache(self, maxsize: int = 10000, tol: float = 1e-14):
        """
        Enable, re-initialize, or disable the per-row result cache.

        Parameters:
            maxsize (int):
                Cache capacity in number of rows. If `maxsize <= 0`, caching is disabled.
                (default=1e5)
            tol (float):
                Relative tolerance used by the cache for both keying and closeness
                checks. If `tol <= 0.0`, caching is disabled. (default=1e-14)

        Notes:
            - Sets `_result_cache` to a new `_ResultCache` instance when both
            `maxsize > 0` and `tol > 0.0`; otherwise sets `_result_cache = None`.
        """
        if maxsize > 0 and type(tol) is list and all([x > 0 for x in tol]):
            self._result_cache = _ResultCache(maxsize, tol)
        elif maxsize > 0 and tol > 0.0:
            self._result_cache = _ResultCache(maxsize, tol)
        else:
            self._result_cache = None

    def __call__(self, x_in: np.typing.ArrayLike | float) -> np.ndarray | float:
        """
        Runs the simulation for the provided input(s) and returns the QoIs.

        Parameters:
            x_in (array or float): A single input vector, or array of input vectors.

        Returns:
            np.ndarray or float:
                - If a single input and single QoI: returns a float.
                - If a single input or single QoI: returns a 1D array.
                - Otherwise, returns a 2D array of shape (num_samples, num_qois).

        Raises:
            ValueError: If the input shape doesn't match expected parameter dimensions
            or the control's output row count does not match the input row count.

        Notes:
            - With caching enabled, each row is looked up in the cache; only misses
              are sent to the underlying control. Rows duplicated within the same
              call are not coalesced (each is treated independently).
        """
        # Convert input to numpy array
        x = self._preprocess(x_in)

        # Fast path: no cache
        if self._result_cache is None:
            return self._postprocess(self._run_control(x))

        # Rows that are not in cache
        nrows: int = x.shape[0]
        y = np.empty((nrows, self._control.num_qois))
        need_run_rows: np.ndarray = np.array([True] * nrows, dtype=bool)
        for i in range(nrows):
            y_cache = self._result_cache.get(x[i, :])
            if not y_cache is None:
                need_run_rows[i] = False
                if isinstance(y_cache.dtype, np.object_):
                    y = y.astype(np.object_)
                y[i, :] = y_cache

        # Run if any rows are not cached
        if any(need_run_rows):
            src = self._run_control(x[need_run_rows, :])
            if src.dtype != y.dtype:
                y = y.astype(src.dtype, copy=False)
            y[need_run_rows, :] = src
            # Store
            for i, store in enumerate(need_run_rows):
                if store:
                    self._result_cache.set(x[i, :], y[i, :])

        # Return
        return self._postprocess(y)

    def _preprocess(self, x_in: np.typing.ArrayLike | float) -> np.ndarray:
        """Convert a iterable or scalar input to a 2-D numpy array."""
        # Convert to numpy array
        x = np.array(x_in)

        # Check dimensionality of array
        dim = len(x.shape)
        if dim == 0:
            x = x.reshape(1, 1)
        elif dim == 1:
            new_shape = (1, -1) if self._control.num_params > 1 else (-1, 1)
            x = x.reshape(new_shape)
        elif dim > 2:
            raise ValueError(
                f"Expecting input to be float, 1-D, or 2-D array; received {dim}-D array."
            )

        # Check array dimensions
        if x.shape[1] != self._control.num_params:
            raise ValueError(
                f"Expecting {self._control.num_params} columns/values in array, got {x.shape[1]}."
            )

        return x

    def _run_control(self, x: np.ndarray) -> np.ndarray:
        """Execute the underlying control for a batch of inputs."""
        # Insert input
        self._control.setInput(x)

        # Run the current state
        self._control.run()

        # Gather reporters
        y = self._control.getOutput()
        if y.shape[0] != x.shape[0]:
            raise ValueError(
                f"Output length does not match input length: {y.shape[0]} vs. {x.shape[0]}."
            )

        return y

    def _postprocess(self, y: np.ndarray) -> np.ndarray | float:
        """Return either float, vector, or matrix based on size of 2-D array."""
        if np.size(y) == 1:  # A single QoI and row
            return y[0, 0]
        elif y.shape[0] == 1 and y.shape.count(1) < len(y.shape) - 1:
            return y[0, :]
        elif y.shape.count(1) >= len(y.shape) - 1:  # A single QoI or row
            return y.reshape(-1)
        else:
            return y
